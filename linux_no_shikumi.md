# 試して理解Linuxの仕組み

# 感想

# 内容
## 1章: コンピュータシステムの概要
- 種類が同じデバイスは同じインターフェースで操作でき、汎用的な開発をできるようにするためにOSが存在している

## 2章: ユーザモードで実現する機能
- システムにはユーザーモードとカーネルモードがあり、プロセスはユーザーモードで動かされる

## 3章: プロセス管理
- Linuxにはプロセス生成は2つの目的がある
    - 同じプログラムの処理を複数のプロセスに分けて処理する(fork関数)
    - 全く別のプログラムを生成する(execve関数)

## 4章: プロセススケジューラ
- Linuxには複数プロセスを同時に動作させる(ように見せている)プロセススケジューラという機能がある
    - 1つのCPU上で同時に処理するプロセスは１つだけ
    - 複数プロセスが実行可能な場合、ここのプロセスを適当な時間ごとにCPU上で順に実行する
        - コンテキストスイッチ(切り替え作業)はオーバーヘッドが生じる
- マルチコアCPUは１つのコアが１CPUとして認識される
- 論理CPUが常に働いている(アイドル状態がない)場合、かつ、実行待ち状態のプロセスがない場合にスループットもレイテンシも最大になる
    - マルチコアCPU環境では複数プロセスを同時に動かさないとスループットが上がらない。「コアがn個あるから性能がn倍！」は最良のケース
    - 単一論理CPUの場合と同じでプロセス数を論理CPU数より多くしてもスループットは上がらない

## 5章: メモリ管理
- 仮想メモリ
    - 物理メモリのアドレスをプロセスと紐付けるためのアドレス
    - 物理メモリに直接アクセスすると起こりうる以下のデメリットを解消している
        - メモリの断片化
        - 別用途のメモリにアクセスできる
        - マルチプロセスの扱いが困難
- ページテーブル
    - 仮想メモリと物理メモリを紐付ける情報で、カーネルが使うメモリ内にある
    - 1ページのサイズは4KB
- コピーオンライト
    - forkシステムコールの実験後、書き込みが行われるまでメモリ領域は親プロセスと子プロセスで共有される
    - メモリ領域への書き込み時にページフォルトが発生し、物理メモリの別の領域を確保する
- スワップ
    - 物理メモリが足りなくなったときに、一時的にディスクの一部をメモリとして使う仕組み

## 6章: 記憶階層
### キャッシュメモリ
- メモリアクセスはレジスタによる計算に比べて10~100倍遅く、それを解消するためにキャッシュメモリが存在する。
- キャッシュメモリはメモリアクセスの数倍から数十倍の速度が出る
- キャッシュメモリがいっぱいになったら、順次削除される
    - キャッシュメモリが頻繁に入れ替わる場合などはスラッシングが発生し大きく性能が下がる

#### 階層型キャッシュメモリ
- 最近のx86_64アーキテクチャのCPUはキャッシュメモリが階層型構造となっている
- キャッシュメモリの情報は /sys/device/system/cpu/cpu[0]/cache/index[0] といったディレクトリにあるファイルの中身を見ればわかる

#### まとめ
- プログラムのワークロードをキャッシュメモリサイズに収めることによって性能を大きく向上できる。
- 速度を重視するようなプログラムにおいては、キャッシュメモリの効果を最大限に活かすために、データ配置やアルゴリズム、設定の工夫によって単位時間あたりの「メモリアクセス範囲を小さくすることが重要
- システムの設定変更でプログラムの性能が大きく劣化する場合はプログラムのデータがキャッシュメモリに乗り切らなくなった可能性がある
