# 試して理解Linuxの仕組み

# 感想

# 内容
## 1章: コンピュータシステムの概要
- 種類が同じデバイスは同じインターフェースで操作でき、汎用的な開発をできるようにするためにOSが存在している

## 2章: ユーザモードで実現する機能
- システムにはユーザーモードとカーネルモードがあり、プロセスはユーザーモードで動かされる

## 3章: プロセス管理
- Linuxにはプロセス生成は2つの目的がある
    - 同じプログラムの処理を複数のプロセスに分けて処理する(fork関数)
    - 全く別のプログラムを生成する(execve関数)

## 4章: プロセススケジューラ
- Linuxには複数プロセスを同時に動作させる(ように見せている)プロセススケジューラという機能がある
    - 1つのCPU上で同時に処理するプロセスは１つだけ
    - 複数プロセスが実行可能な場合、ここのプロセスを適当な時間ごとにCPU上で順に実行する
        - コンテキストスイッチ(切り替え作業)はオーバーヘッドが生じる
- マルチコアCPUは１つのコアが１CPUとして認識される
- 論理CPUが常に働いている(アイドル状態がない)場合、かつ、実行待ち状態のプロセスがない場合にスループットもレイテンシも最大になる
    - マルチコアCPU環境では複数プロセスを同時に動かさないとスループットが上がらない。「コアがn個あるから性能がn倍！」は最良のケース
    - 単一論理CPUの場合と同じでプロセス数を論理CPU数より多くしてもスループットは上がらない

## 5章: メモリ管理
- 仮想メモリ
    - 物理メモリのアドレスをプロセスと紐付けるためのアドレス
    - 物理メモリに直接アクセスすると起こりうる以下のデメリットを解消している
        - メモリの断片化
        - 別用途のメモリにアクセスできる
        - マルチプロセスの扱いが困難
- ページテーブル
    - 仮想メモリと物理メモリを紐付ける情報で、カーネルが使うメモリ内にある
    - 1ページのサイズは4KB
- コピーオンライト
    - forkシステムコールの実験後、書き込みが行われるまでメモリ領域は親プロセスと子プロセスで共有される
    - メモリ領域への書き込み時にページフォルトが発生し、物理メモリの別の領域を確保する
- スワップ
    - 物理メモリが足りなくなったときに、一時的にディスクの一部をメモリとして使う仕組み

## 6章: 記憶階層
### キャッシュメモリ
- メモリアクセスはレジスタによる計算に比べて10~100倍遅く、それを解消するためにキャッシュメモリが存在する。
- キャッシュメモリはメモリアクセスの数倍から数十倍の速度が出る
- キャッシュメモリがいっぱいになったら、順次削除される
    - キャッシュメモリが頻繁に入れ替わる場合などはスラッシングが発生し大きく性能が下がる

#### 階層型キャッシュメモリ
- 最近のx86_64アーキテクチャのCPUはキャッシュメモリが階層型構造となっている
- キャッシュメモリの情報は /sys/device/system/cpu/cpu[0]/cache/index[0] といったディレクトリにあるファイルの中身を見ればわかる

#### まとめ
- プログラムのワークロードをキャッシュメモリサイズに収めることによって性能を大きく向上できる。
- 速度を重視するようなプログラムにおいては、キャッシュメモリの効果を最大限に活かすために、データ配置やアルゴリズム、設定の工夫によって単位時間あたりの「メモリアクセス範囲を小さくすることが重要
- システムの設定変更でプログラムの性能が大きく劣化する場合はプログラムのデータがキャッシュメモリに乗り切らなくなった可能性がある

### ページキャッシュ
- CPUからメモリへのアクセス速度に対し、ストレージへのアクセス速度は非常に遅い
    - これを解決する仕組みがページキャッシュ。
    - ストレージデバイス上のファイルデータをメモリにキャッシュするもの
- 同期書き込みはopen時にO_SYNCオプションで可能

#### チューニングパラメータ
- ダーティページのライトバック周期はsysctlのvm.dirty_writeback_centisecs 単位はセンチ秒(1/100秒)
- ダーティページの占める割合がどの程度になったらバックグラウンドでライトバックを動作させるかは vm.dirty_background_ration 単位は%

#### まとめ
ファイルのデータがページキャッシュにあるかないかでファイルアクセスの速度は段違いになる

### ハイパースレッド
- CPU使用時間のうちの多くはメモリやキャッシュメモリからのデータ転送待ち時間のために空費している
    - CPUの計算処理の所要時間に比較して、キャッシュメモリのレイテンシも若干遅いため
- CPU使用時間の空費を抑えるためにハイパースレッド機能がある
    - CPUコアの中のレジスタなどの一部の資源を複数用意し、それぞれシステムからは論理CPUとして認識されるように分割する機構
    - 条件が揃えば、スループットの性能が2~30%向上する
    - 場合によってはスループットが低下する場合すらあるので注意

## 7章: ファイルシステム
- ファイルシステムはユーザにとって意味のあるひとかたまりのデータを、名前、位置、サイズなどの補助的な情報を付加した上で、ファイルという他院ににして管理する
    - このおかげでユーザーは各データの名前さえ覚えておけば各データのストレージデバイス上の位置やサイズなどの雑多な情報を記憶しておかなくて済む
- Lunuxの扱えるファイルシステムは１つではなく、ext4/XFS/Btrfsなどがあるが、システムコールのインターフェースは統一されている

### メタデータ
- dfコマンドはメタデータ合計サイズも含む

### 容量制限
- クォータと呼ばれる機能で、用途ごとに使用できるファイルシステムの容量を制限している
    - ユーザークォータ
    - ディレクトリクォータ
    - サブボリュームクォータ

### ファイルシステムの不整合
一連の切り離せない処理(アトミックな処理)中に電源が落ちる等で不整合が起きた場合、ジャーナリングやコピーオンライトの仕組みでリカバリをする

#### ジャーナリング
#### コピーオンライト
