# 試して理解Linuxの仕組み

# 感想

# 内容
## 1章: コンピュータシステムの概要
- 種類が同じデバイスは同じインターフェースで操作でき、汎用的な開発をできるようにするためにOSが存在している

## 2章: ユーザモードで実現する機能
- システムにはユーザーモードとカーネルモードがあり、プロセスはユーザーモードで動かされる

## 3章: プロセス管理
- Linuxにはプロセス生成は2つの目的がある
    - 同じプログラムの処理を複数のプロセスに分けて処理する(fork関数)
    - 全く別のプログラムを生成する(execve関数)

## 4章: プロセススケジューラ
- Linuxには複数プロセスを同時に動作させる(ように見せている)プロセススケジューラという機能がある
    - 1つのCPU上で同時に処理するプロセスは１つだけ
    - 複数プロセスが実行可能な場合、ここのプロセスを適当な時間ごとにCPU上で順に実行する
        - コンテキストスイッチ(切り替え作業)はオーバーヘッドが生じる
- マルチコアCPUは１つのコアが１CPUとして認識される
- 論理CPUが常に働いている(アイドル状態がない)場合、かつ、実行待ち状態のプロセスがない場合にスループットもレイテンシも最大になる
    - マルチコアCPU環境では複数プロセスを同時に動かさないとスループットが上がらない。「コアがn個あるから性能がn倍！」は最良のケース
    - 単一論理CPUの場合と同じでプロセス数を論理CPU数より多くしてもスループットは上がらない

## 5章: メモリ管理
- 仮想メモリ
    - 物理メモリのアドレスをプロセスと紐付けるためのアドレス
    - 物理メモリに直接アクセスすると起こりうる以下のデメリットを解消している
        - メモリの断片化
        - 別用途のメモリにアクセスできる
        - マルチプロセスの扱いが困難
- ページテーブル
    - 仮想メモリと物理メモリを紐付ける情報で、カーネルが使うメモリ内にある
    - 1ページのサイズは4KB
- コピーオンライト
    - forkシステムコールの実験後、書き込みが行われるまでメモリ領域は親プロセスと子プロセスで共有される
    - メモリ領域への書き込み時にページフォルトが発生し、物理メモリの別の領域を確保する
- スワップ
    - 物理メモリが足りなくなったときに、一時的にディスクの一部をメモリとして使う仕組み

## 6章: 記憶階層
### キャッシュメモリ
- メモリアクセスはレジスタによる計算に比べて10~100倍遅く、それを解消するためにキャッシュメモリが存在する。
- キャッシュメモリはメモリアクセスの数倍から数十倍の速度が出る
- キャッシュメモリがいっぱいになったら、順次削除される
    - キャッシュメモリが頻繁に入れ替わる場合などはスラッシングが発生し大きく性能が下がる

#### 階層型キャッシュメモリ
- 最近のx86_64アーキテクチャのCPUはキャッシュメモリが階層型構造となっている
- キャッシュメモリの情報は /sys/device/system/cpu/cpu[0]/cache/index[0] といったディレクトリにあるファイルの中身を見ればわかる

#### まとめ
- プログラムのワークロードをキャッシュメモリサイズに収めることによって性能を大きく向上できる。
- 速度を重視するようなプログラムにおいては、キャッシュメモリの効果を最大限に活かすために、データ配置やアルゴリズム、設定の工夫によって単位時間あたりの「メモリアクセス範囲を小さくすることが重要
- システムの設定変更でプログラムの性能が大きく劣化する場合はプログラムのデータがキャッシュメモリに乗り切らなくなった可能性がある

### ページキャッシュ
- CPUからメモリへのアクセス速度に対し、ストレージへのアクセス速度は非常に遅い
    - これを解決する仕組みがページキャッシュ。
    - ストレージデバイス上のファイルデータをメモリにキャッシュするもの
- 同期書き込みはopen時にO_SYNCオプションで可能

#### チューニングパラメータ
- ダーティページのライトバック周期はsysctlのvm.dirty_writeback_centisecs 単位はセンチ秒(1/100秒)
- ダーティページの占める割合がどの程度になったらバックグラウンドでライトバックを動作させるかは vm.dirty_background_ration 単位は%

#### まとめ
ファイルのデータがページキャッシュにあるかないかでファイルアクセスの速度は段違いになる

### ハイパースレッド
- CPU使用時間のうちの多くはメモリやキャッシュメモリからのデータ転送待ち時間のために空費している
    - CPUの計算処理の所要時間に比較して、キャッシュメモリのレイテンシも若干遅いため
- CPU使用時間の空費を抑えるためにハイパースレッド機能がある
    - CPUコアの中のレジスタなどの一部の資源を複数用意し、それぞれシステムからは論理CPUとして認識されるように分割する機構
    - 条件が揃えば、スループットの性能が2~30%向上する
    - 場合によってはスループットが低下する場合すらあるので注意

## 7章: ファイルシステム
- ファイルシステムはユーザにとって意味のあるひとかたまりのデータを、名前、位置、サイズなどの補助的な情報を付加した上で、ファイルという他院ににして管理する
    - このおかげでユーザーは各データの名前さえ覚えておけば各データのストレージデバイス上の位置やサイズなどの雑多な情報を記憶しておかなくて済む
- Lunuxの扱えるファイルシステムは１つではなく、ext4/XFS/Btrfsなどがあるが、システムコールのインターフェースは統一されている

### メタデータ
- dfコマンドはメタデータ合計サイズも含む

### 容量制限
- クォータと呼ばれる機能で、用途ごとに使用できるファイルシステムの容量を制限している
    - ユーザークォータ
    - ディレクトリクォータ
    - サブボリュームクォータ

### ファイルシステムの不整合
一連の切り離せない処理(アトミックな処理)中に電源が落ちる等で不整合が起きた場合、ジャーナリングやコピーオンライトの仕組みでリカバリをする

#### ジャーナリング
- ファイルシステム内にジャーナル領域という特殊な領域を用意する(ユーザーには認識できない領域)
- ジャーナル領域に必要な操作を書き出す
- ジャーナル領域の内容をもとにデータを書き換える
- ジャーナル領域を捨てる

#### コピーオンライト
- ファイルを編集する際に、もとのファイルAと編集するファイルA'を別で保持し、保存時にAとA'のリンクを張り替える方式

### ファイルの種類
- 通常ファイルとディレクトリ以外にデバイスファイルがある
    - キャラクタデバイス
        - 読み出しと書き出しはできるがシークはできない
            - 端末
            - キーボード
            - マウス
    - ブロックデバイス
        - ファイルの読み書き以外にランダムアクセスができる(HDD/SSD)
            - パーティションテーブルの更新
            - ブロックデバイスレベルのデータのバックアップとリストア
            - ファイルシステムの作成
            - ファイルシステムのマウント
- 各デバイスは /dev 以下に保存され、lsしたときにcで始まるのがキャラクタデバイス、bで始まるのがブロックデバイス

### 仮想ファイルシステム
#### procfs
- 通常 /proc 以下にマウントされる
- /proc/{pid} 以下にファイルにアクセスすることによって各プロセスの情報を得られる
    - /proc/{pid}/maps プロセスのメモリマップ
    - /proc/{pid}/cmdline プロセスのコマンドライン引数
    - /proc/{pid}/stat プロセスの状態、CPU時間、優先度、使用メモリ量など
- 以下の情報も得られる
    - /proc/cpuinfo システムが搭載するCPUに関する情報
    - /proc/diskstat システムが搭載するストレージデバイスに関する情報
    - /proc/meminfo システムのメモリに関する情報
    - /proc/sys以下 カーネルの各種チューニングパラメータ

#### sysfs
- 通常 /sys 以下にマウント
    - /sys/devices以下 システムに搭載されているデバイスに関する情報
    - /sys/fs以下 システムに存在する各種ファイルシステムに関する情報

### Btrfs
ext4やXFSなどよりも豊富な機能を持つファイルシステム

#### マルチボリューム
- １つないし複数のストレージデバイス/パーティションから大きなストレージプールを作った上で、その上にマウント可能なサブボリュームという領域を作成
- ファイルシステム+LVMのようなボリュームマネージャと考えるとわかりやすい

#### スナップショット
- データを参照するためのメタデータの作成のため、コピーよりも圧倒的に高速

#### RAID
- BtrfsではファイルシステムレベルでRAID構成を組める
    - RAID0, 1, 10, 5, 6とdupをサポート

#### データ破損検知/修復
- データ、メタデータともに所定のデータ長ごとにチェクサムを持つことによって、データの破損検知が可能

## 8章: ストレージデバイス 
### HDDのデータ読み書きの仕組み
- HDDはデータを磁気情報で表現して、それをプラッタと呼ばれる磁気ディスクに記憶するストレージデバイス
- データはバイト単位ではなく、セクタと呼ばれる単位で読み書きする
- スイングアームの動作とプラッタの回転は機械的な処理のため、非常に遅い

### HDDの性能特性
- HDDは連続する複数のセクタのデータを一度のアクセスによってまとめて読み出せる
- 連続していないセクタにアクセスする場合はHDDへ複数回アクセス依頼しなくてはならない上に回転数が必要になる

### ブロックデバイス層
ブロックデバイス(HDD/SSD)には以下の二種類がある
- デバイスファイルと呼ばれる特殊なファイルによって直接アクセス
- その上に構築された ファイルシステムを介して間接的にアクセス(こっちが主流)

#### IOスケジューラ
ブロックデバイスへのアクセス要求を一定期間ためておいて、以下のような加工をしてからデバイスドライバにI/Oの要求をする
- マージ: 複数の連続するセクタへのI/O要求を一つにまとめる
- ソート: 複数の不連続なセクタへのI/O要求をセクタ番号順に並べ替える

#### 先読み
ストレージデバイス内のある領域にアクセスした歳にその直後にそれに続く領域にアクセスする可能性が高いと推測して、事前に先読みする機能

### SSDの仕組み
SSDの場合はデータへのアクセスに機械的な動作がなく、電気的な動作だけで済む


