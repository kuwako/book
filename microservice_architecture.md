# マイクロサービスアーキテクチャ(オライリー)
# 1章: マイクロサービス
## メリット
- 各サービスで違った技術を採用でき、それぞれでデプロイできる
- 回復性が高い
- スケーリングが容易

## デメリット
- オーバーヘッドが大きい
- 小さいサービスには向いていない
- 必要なリソースが増える

# 2章 進化的アーキテクト
- マイクロサービスアーキテクチャでは、予測が困難な状況の下で多くのトレードオフな判断が必要になる
    - 目標と、それを実現するための原則とプラクティスを定めることで対処する

# 3章 サービスのモデル化方法
- 独立してデプロイできる疎結合性と、ドメインの境界づけられたコンテキストでまとめられた高凝縮性が必要
- 経験のないドメインを扱う場合は最初はモノリスで作って、ドメインの理解が進んでからマイクロサービスに分離していくと良い
- コンテキスト境界を分離する際には、データで切るのではなく、コンテキストが外部に公開する振る舞い(ドメイン)に注目する
- DBは必ず分割すること

# 4章 統合
- APIを技術に依存させないようにする
- 共有DBは強い凝縮性と疎結合の両方を失うので避けるべき。絶対に避けるべき。
- RESTとRPCとの間のトレードオフを理解し、RESTをリクエスト/レスポンス結合の優れた出発点であると認める
- ユーザーインターフェースを合成レイヤーと捉える

# 5章 モノリスの分割
- モノリスを分割するには、少しずつ切り崩すのが良さそう
- 実践の中でマイクロサービスを学ぶため(どうせ最初はうまくいかないだろう)
- 外部キー関係の削除(整合性を保証できなくなる)
- 共有静的データ(国コードなど)
    - 列挙型でコードとして管理するのが結局おすすめ
- 共有データ(顧客データなど)
    - それはもうドメインでは、ということに注目し顧客サービスを作る
- まずはDBから分割し、その後アプリケーション側を分割してマイクロサービスにする
- トランザクション境界
    - あとでリトライ(結果整合性)
    - 操作全体の中止が必要な場合が出てくるが、打ち消しようのdelete文すら失敗の可能性があり、不安定
    - 例えば、処理中の注文という概念を考え出す必要がある
- レポートなどが必要な場合、必要な情報をバッチ的にまとめて取得するAPIを設けないと死ぬ
- データポンプ
    - httpのオーバーヘッドが大きいので、レポート用に定期的にデータを送るシステムを採用するのもあり
 
