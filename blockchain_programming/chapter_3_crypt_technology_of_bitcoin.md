# 第3章: ビットコインの暗号化技術
## 利用する暗号ライブラリ
Rubyを主に使用する
- openssl
- securerandom
- ruby_ecdsa
- bitcoin-ruby

### openssl 
rubyから使う際は require 'openssl' で呼び出せる

### 安全な乱数の重要性
ほとんどの暗号システムは擬似乱数を生成するシステムと言える
- それほど擬似乱数が予測不能な真の乱数にどれだけ近いかが重要
- コンピュータの計算でできる暗号鍵の生成や暗号化はシードと呼ばれる乱数の素を使う
    - シードが同じであれば最終的な出力は同じになってしまう
- コンピュータの時計をシードに使うのことはできない
    - 市販の高性能なPCでも2の50乗くらいの計算は実行できてしまう
    - 1μsの2の50乗は約35年にあたる
- ハードウェア乱数生成器が備わっている
    - AppleA7以降のプロセッサなどには熱雑音などを利用して物理的に乱数を発生させる
- エントロピープール
    - ハードウェアやデバイスドライバなどから発生するデータを乱数の素として大量に蓄積していく
    - LinuxやMacOSXはこの方式

### securerandomによる安全な乱数
- Rubyから安全な乱数を生成するためのライブラリ

### ruby_ecdsa
- OpenSSLにビットコインで利用されるECDSAという暗号技術を利用するための昨日が備わっているのでopensslライブラリで十分  
- ただし、細かいECDSAのテクニックを確認するにはruby_ecdsaが便利

### bitcoin-ruby
ビットコインの全ての基本機能をRubyで実装したライブラリ
- Bitcoin::Util
    - ビットコインの共通で使われる暗号処理やエンコーディングなどのユーティリティ
- Bitcoin::Protocol
    - ビットコインネットワークのプロトコルに沿ったメッセージの構文解析や生成
- Bitcoin::Script
    - ビットコインの備わっているスクリプト言語処理系のスクリプトの作成や実行と電子署名の検証など
- Bitcoin::Key
    - 暗号鍵やビットコインアドレスなどの様々な処理に関するAPI
- Bitcoin::Builder
    - トランザクションやブロックを作成するための高度なAPI

## ビットコインに利用されて炒る暗号技術の基本
ビットコインは枯れた技術の組み合わせによってできている

### 暗号学的ハッシュ関数
一方向関数

#### メッセージのダイジェスト
ある処理が同じ入力に対しては必ず同じ値を返す性質（決定性）がある

#### メッセージの完全性を検証する手段
1bitでも改ざんされていれば全く別の値になることを利用した安全性の検証

#### メッセージへのコミットメント
メッセージにnonce(一度きりしか使わないランダムな数値のこと)を追加した上でそのハッシュ値を計算し、ハッシュとメッセージのみを公開することで、そのnonceを知っている者にしか計算できない  
- ハッシュ値を実際に計算した人は使用したnonceを開示することによって、第三者に対して自分がそのメッセージのハッシュ値を本当に作成したことを証明できる  
- ハッシュ値を使ってメッセージとハッシュ計算を行った人間を確実に紐づけることをコミットメントと呼ぶ

ビットコインのマイニングとはnonceを変更しながらブロックのデータのハッシュ値を繰り返し計算すること
- マイニング競争とは次々とのんcえを変更しながらハッシュ値を計算し、それとターゲットと呼ばれる数値を比較し、世界で最初にターゲットよりも小さいハッシュ値を得たものが勝利者となる
- マイニングの結果得られるnonceのことをproof of workという

#### データ参照のためのポインタ
- ソフトウェア高額ではキーによって直接的にデータを参照できるデータ構造としてハッシュテーブルを使う方法がある
- ハッシュ値をメッセージとみなして再びそのハッシュ値を計算したり、ハッシュ値の間の連続構造を改変不可能にすることをハッシュチェーンと呼ぶ
- データの構造かに加えてデータ間の順序関係の維持、欠落や追加ができないことなどを証明するためのコミットメントとして利用が可能

#### データがコミットされたメンバーであることやメンバーでないことの証明手段としての利用方法
マークル木
- ハッシュチェーンの一つ
- 暗号学的ハッシュ関数のハッシュ値をポインタとして利用

#### 暗号学的ハッシュ関数の衝突耐性
- 別のメッセージから同じハッシュ値が出力されてしまうことをハッシュ値の衝突と呼ぶ
- 暗号学的ハッシュ関数は、ハッシュ値の衝突確率が極めて低い
- 理想の衝突確率はハッシュ値のサイズの平方根よりはよくできないとされる
    - ハッシュ値が160ビットの暗号学的ハッシュ関数であれば衝突耐性の理想は160ビットの平方根 = 1 / 2の80乗
- SHA-1の暗号学的ハッシュ関数(160ビット)は効率的な攻撃方法が見つかった
    - ハッシュ値の衝突確率を 1 / 2の61乗 まで増やすことができる
    - 条件次第では現実的に攻撃可能
    - 2017年2月23日、Googleが2つのPDFファイルのSHA-1ハッシュの衝突に成功

### ビットコインにおける暗号学的ハッシュ関数の利用
- ビットコインアドレスは公開鍵のダイジェスト
- ビットコインアドレスはチェックサムとしてハッシュ値の一部を利用
- トランザクションの識別子はトランザクションのハッシュ値
- ブロック内の情報や含まれるトランザクション群の内容への完全性の保証
- ブロックの連鎖構造（ブロックチェーン）においてブロックの順序の保持、追加や欠落を不可能にするコミットメント
- マイニング計算とそのコミットメント
- マイニング計算とそのコミットメント(HashCash法)
- トランザクションの恒星時に直前のトランザクションを参照するためのポインタ
- マークル木というハッシュ値のポインタによる木構造を利用したメンバー判定の効率化
- 検索者の検索対象に関するプライバシを守りながらブロック内のメンバーを探索するフィルタ（ブルームフィルタ）

ビットコインではSHA-256とRIPEMD-160という2種類の暗号学的ハッシュ関数を用いている

### 公開鍵暗号
#### 公開鍵と秘密鍵
- 自分だけができる固有の計算能力を相手に示すことで本人であることを証明する
    - 自分だけができることを示すために自分の秘密の情報を使う
- 例(サービス側が自分の公開鍵を持っている場合)
    - サービス側から送られてきたランダムなデータを自分の秘密鍵を使って計算し、結果をサービス側に返す
    - サービス側はその人の公開鍵を使ってその計算結果を調べることで本人であることを確認
    - 当然、秘密鍵は誰にも渡してはいけない

#### 当事者の識別子としての公開鍵
公開鍵基盤(PKI)
- 全ての当事者がそれぞれ自分の公開鍵と秘密鍵のペアを持っているという社会的な前提のこと

仮名(pseudonym)
- 実態と切り離された名前のこと
- SSL/TLSなどで利用するタイプのPKIは公開鍵証明書の中に本人の実名やTLSサーバーのFQDNなどの実世界の実態を参照する名前が入っている
- 積極的に実態の隠蔽を目的とする匿名(anonymity)とは区別される

ビットコインは一種の公開鍵暗号基盤と呼べる

#### 電子署名
文書への押印やサインを行う行為とよく似た昨日を持つ公開鍵暗号技術
- メッセージの作成者が誰か 
- そのメッセージが1ビットも改竄されてないこと

の二つを証明できる

#### ECDSA
ビットコインではECDSA(楕円曲線DSA)と呼ばれる電子署名のための公開鍵暗号が用いられている
- DSA(Digital Signature Algorithm)とはアメリカ国立標準技術研究所(NIST)によって標準化された電子署名
- 電子署名お過程で擬似乱数を使う

##### ECDSAの基本機能
- 暗号鍵生成
- 電子署名作成
- 電子署名検証

#### 楕円曲線暗号
- 楕円関数論という数学

#### 楕円曲線状の離散対数問題
離散対数問題(DLP)
- 離散べき乗を逆に計算する問題
- 多項式時間で計算する方法が見つかっていない
- 一部の楕円曲線はEC-DLPを解く多項式時間アルゴリズムが存在するので、曲線の選び方は注意が必要

### ECDSAによる電子署名
- メッセージのダイジェストの作成、電子署名の作成、電子署名のエンコーディングとデコーディング、電子署名の検証

#### 署名者の公開鍵と秘密鍵の生成
- 電子署名の署名者の秘密鍵が必要

#### メッセージのダイジェストの作成
- secp256klによる電子署名の入力は256ビットしかないので、長いメッセージを直接署名できない
- メッセージに対してSHA-256でハッシュ値を計算

## ビットコインアドレス
公開鍵暗号の主な用途は
- 暗号鍵の交換
- 電子認証
- 電子署名

ビットコインの送金は原理的には送金先の公開鍵さえあればできる  
公開鍵のペアとなる秘密鍵をもつ受療者が実在しているかは関係ない  
- 実際に送金先として利用されている公開鍵はない
- ビットコインで実際に送金を表す「固有名」はビットコインアドレス
    - ビットコインアドレスは公開鍵と1対1に対応している
    - 公開鍵とビットコインアドレスの対応関係は公開鍵の正真性の検証を行う計算で確認できる

### ビットコインアドレスの作成方法
アドレスに一文字でも間違いがあれば戻ってこないので、それを軽減する仕組みがある
- チェックサム
- プレフィックス
- base58エンコーディング

ビットコインアドレスは
- バージョン情報を表すプレフィックス
- 公開鍵から生成されるペイロード
- 内容の間違いを検出するためのチェックサム
からできている

### base58エンコーディング
ビット列を英数字の文字列としてエンコードする一般的な方法はbase64エンコーディング
- base58は見間違いの多いl, I, 0, Oの四文字と+, /, =を使わないようにした58進数のもの

### プレフィックス
ビットコインアドレスの先頭1バイトはバージョンや種別を表すために利用される

### チェックサム
入力されたアドレスに間違いがあった場合にそれを検出できるようにするための付加情報

### ペイロード
- データの実体のこと
- ビットコインアドレスでは、公開鍵に対してSHA256を使ったhash値にRIPEMD-160を使ってhash値を求めたものがペイロード

### Base58Checkエンコーディング
人為的なミスを少なくするために
- 先頭1バイトのプレフィックスを持ち
- 最後の4バイトが内容の誤りをチェックするためのチェックサムとし
- 全体をbase58でエンコードする

データ形式をBase58checkエンコーディング形式という

## 暗号鍵のフォーマット
- ビットコイン公開鍵には圧縮の処理を行なっていない形式とほぼ半分サイズに圧縮されたものがある
- 秘密鍵も非圧縮の公開鍵で利用されるものと圧縮形式の公開鍵に対応するものがある
- 当初非圧縮のものが使われていたが、ブロックサイズを圧迫するようになってからは圧縮されたものが使われるようになった

### 公開鍵のフォーマット
公開鍵はBase58Check形式でなく16進数で扱われる

#### 非圧縮形式の公開鍵
ECDSA secp256klの公開鍵はスカラーではなく、それぞれ256ビットのx座標とy座標のベクトル  
このxとyの値を16進数文字列で連接し、先頭に0x04という1バイトのプレフィックスをつけたものが非圧縮形式の公開鍵  
- 非圧縮形式の公開鍵のサイズは520バイト

#### 圧縮形式の公開鍵
- 楕円曲線関数は y^2 = x^3 + 7(mod(p)) を満たすので、xが決まればyが決まる
    - xの256ビットだけで公開鍵が決まる
    - ただし、正か負かの判定ができないため、プレフィックスを付加する

### 秘密鍵のフォーマット
#### 秘密鍵のバックアップの重要性
秘密鍵がなくなってしまうと自分の所持金は2度と動かせん苦なるためバックアップが必須

#### WIF(Wallet import format)
ビットコインの秘密鍵はecdsaのsccp256klの256ビットの整数  
WIF形式の秘密鍵は
- 256ビットの秘密会gの16進数表現
- プレフィックス0x80(mainnet)か0xef(testnet)
- 4バイトのチェックサム
- base58エンコードしたもの

## 匿名化とゼロ知識証明
ゼロ知識証明
- Goldwasser, Micali, Rackoffらによって発明された(1985年)
- 証明システムに一切の情報が渡らないということ
    - ECDSAの電子署名はゼロ知識性を持たない
        - ECDSAの電子署名の検証は、署名者の秘密鍵を知ることなしに署名が真性なものか偽造されたものか判断できるが
        - ECDSA電子署名(r, s)のrは署名に使われたnonceによって一意に決定されるので、2回同じnonceを使うと秘密鍵がわかってしまう
        - つまり電子署名が行われるたびに秘密鍵に関連した情報が少しずつ漏れている
        - よってゼロ知識証明ではない

#### 匿名性とゼロ知識証明
ゼロ知識証明は秘密情報を知っている人以外には直接その事実を確認できないような命題を利用する
- 巨大な数の素因数分解、離散対数問題、ハミルトン閉路問題などが該当する
- 実際に秘密情報を持っている or 持っているフリをする人を「証明者」Pと呼ぶ
- 証明システムを「検証者」Vと呼ぶ

ゼロ知識証明のポイントは検証者Vが1回のプロトコルの実行で、確定的に証明者Pに関する命題をacceptしたりrejectしたりするのではない  
複数回のやりとり(対話)を行う中で確率的にacceptかrejectかの結果を収束させていく  
- 実は非対話化も可能






































