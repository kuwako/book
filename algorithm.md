# 3章 探索
## 線形探索
配列の先頭から各要素が目的の値と等しいかどうかを順番に調べる。効率は悪い。

## 2分探索
データが昇順、降順で並んでる場合に中央の値との大小関係をチェック、中央の値より小さければ前方、大きければ後方を調べる
これを繰り返す

## ハッシュ法
ハッシュ関数で要素の格納場所を決定する
要素のキーを引数とした関数を呼び出すだけでその位置を特定することができるので、データの種類によってはより高速なデータの検索が可能になる

# 6章 分割統治法
1. 与えられた問題を部分問題に「分割」する(Divide)
1. 部分問題を再帰的に解く(Solve)
1. 得られた部分問題の解を「統合」して、元の問題を解く(Conquer)

# 7章 高等的整列
## 7.1 マージソート
バブルソートなどのO(n^2)の初等的なあアルゴリズムは大きなサイズの配列に対しては実用的ではない  
マージソートは大きなサイズのデータに対応することのできる高等的なアルゴリズムである  
マージソートは配列全体を対象としてソートを行う  
1. 指定されたnこの要素を含む部分配列をそれぞれn/2この要素を含む二つの部分配列に分割する(Divide)
1. その二つの部分配列をそれぞれmergeSortでソートする(Solve)
1. 得られた2つのそーと済み部分配列をmergeにより結合する(Conquer)

マージソートの計算量はO(nlogn)になる  
マージソートは安定なソート  
マージソートは高速で安定なアルゴリズムだが、入力データを保持する配列以外に一時的なメモリ領域が必要になる特徴を持つ  

## 7.2 パーティション
パーティションの処理はO(n)のアルゴリズムになる  
不安定なソートなので注意  

## 7.3 クイックソート
クイックソートは次のような分割統治法に基づくアルゴリズムです
1. partitionにより対象の部分配列を前後2つの部分配列へ分割する(Divide)
1. 前方の部分配列に対してquickSortを行う(Solve)
1. 後方の部分配列に対してquickSortを行う(Solve)

クイックソートはpartitionの内部で離れた要素の交換を行うので安定なソートではない  
一方でマージソートがO(n)の外部メモリを必要としたのに対し、クイックソートは追加のメモリ領域を必要としない、いわゆるインプレースソートである  
クイックソートの平均計算量はO(nlogn)で一般的にもっとも高速なソートアルゴリズムとして知られているが、データの並びによっては(例えば、ソート済みのデータ)に対しては効率が悪くなり、最悪の場合O(n^2)の計算量になってしまう  
データのならびによっては再帰が深くなり、スタックオーバーフローが怒る可能性もある  

## 7.4 計数ソート
計数ソートは、入力配列Aの要素を後ろから選んでいくことで安定なソートになる  

# 8章 木
## 8.1 木構造
### 根付き木
- 根(root)と呼ばれる他と区別された1つの接点を持つ木を根付き木と呼ぶ
- 根は親を持たない

### 二分木
- 1つの親を持ち、全ての接点についてこの数が2以下である木を根付き二分木と呼ぶ

## 8.2 根付き木
- 木の高さをhとして各節点の深さを求めるアルゴリズムの計算量は各節点から親をたどっていくアルゴリズムの計算量はO(h)となり、すべての接点について深さを求めるとO(nh)のアルゴリズムになる
- 一方、再帰的に計算していくアルゴリズムは各節点を一度ずつ訪問するのでO(n)のアルゴリズムになる

## 8.3 二分木
- 高さを求めるアルゴリズムでは、各節点の左の子(存在する場合)の高さ+1と、右の子(存在する場合)の高さ+1の大きい方をその節点の高さとする処理を再帰的に行なっているのでO(n)のアルゴリズム

# 9章 二分探索木
連結リストの要素探索にはO(n)の計算量が必要となるが二分探索木を用いれば、もっと効率的になる

## 9.1 二分探索木
探索機は挿入、検索、削除などの操作が行えるデータ構造で、辞書あるいは優先度付きキューとして用いることができ、二分探索木はもっとも基本的なもの。  
二分探索木は各節点にキーを持ち、次に示す二分探索木条件(Binary search tree property)を常に満たすように構築される
xを任意の節点としたとき
- yをxの左部分木に属する節点とすると、yのキー < xのキーとなる
- zをxの右部分木に属する節点とすると、zのキー > xのキーとなる

## 9.2 挿入
二分探索木の挿入操作の計算量は気の高さをhとするとO(h)となる  
節点の数をnとすると、入力に偏りがなければO(logn)になる  
一般的には、挿入されるキーとそれらの順番によって木の高さが高くなる可能性があり、最悪の場合は接点の数nに近づき、計算量がO(n)になる

## 9.3 探索
探索の操作も挿入と同様に木の高さをhとするとO(h)のアルゴリズムになる  

## 9.4 削除
削除もO(h)のアルゴリズムになる

# 10章 ヒープ
- 優先度付きキューは二分探索木を応用して実現することができるが、バランスを保つことは難しい
- 二分ヒープというデータ構造を用いれば比較的簡単に優先度付きキューを実装できる

## 10.1 二分ヒープ
気の各節点に割り当てられたキーが1つの配列の各要素に対応した完全二分木で著されたデータ構造  
二分ヒープは論理的な構造は完全二分木となるが、実際は1オリジンの1次元配列を用いている  
二分ヒープを表す配列をA、二分ヒープのサイズ(要素数)をHとすればA[1,...,H]に二分ヒープの要素が格納される  
根の添字は1で、節点の添字iが与えられた時、その親parent(i), 左の子left(i), 右の子right(i)はそれぞれi/2, 2i, 2i+1で算出できる  


二分ヒープの各節点のキーは、次に示すヒープ条件を保つように格納される
- max-ヒープ条件: 節点のキーがその親のキー以下である
- min-ヒープ条件: 節点のキーがその親のキー以上である

## 10.2 完全二分木
二分ヒープは完全二分木で実装されるので、1つの一次元配列に1オリジンでキーの列を入力する  
完全二分木の各節点番号iについてその親、左の子、右の子の節点番号を求める計算式を適用し、節点の情報を順番に出力する  

# 11章 動的計画法
一度計算した結果をメモリに記録しておき、同じ計算を繰り返し行う無駄を避ける1手法

## 11.2 フィボナッチ数列
F(0) = 1, F(1) = 1, n > 1 のとき、F(n) = F(n - 1) + F(n - 2) なのでF(n)を逐一配列に入れれば計算量が激減する

## 11.3 最長共通部分列
nとmの2重ループO(nm)のアルゴリズム

## 11.4 連鎖行列積
O(n^3)のアルゴリズムになる

# 12章 グラフ
## 12.1.1 グラフの種類

|名前|特徴|
|:--|:--|
|無向グラフ|エッジ(辺)に方向がないグラフ|
|有向グラフ|エッジに方向があるグラフ|
|重み付き無向グラフ|エッジに重みがあり、方向がないグラフ|
|重み付き有向グラフ|エッジに重みがあり、方向があるグラフ|

## 12.1.2 グラフの表記と用語
頂点の集合をV  
辺の集合をE  
のグラフをG(V, E)  
頂点の数を|V|  
辺の数を|E|  
2つの頂点う、vを結ぶ辺をe=(u, v)とし、無向グラフの場合(u, v)は(v, u)と等しい  
視点と終点が同じようなパスを閉路(cycle)と呼ぶ  
閉路のない有向グラフをDirectedAcyclicGraph(DAG)と呼ぶ  
頂点uに繋がっている辺の数を頂点uの次元と呼び、有向フラグの場合、自分から出る辺の数を出次数、自分に入る辺の数を入次数と呼ぶ

## 12.1.3 グラフの基本的なアルゴリズム
グラフにおけるモットモキホンテキナアルゴリズムが探索  
代表的な探索アルゴリズムが
- 深さ優先探索 (DFS: Depth First Search)
    - 行けるところまでとことん行くというルールに従ったグラフにおける最も自然で基本的な探索アルゴリズム
- 幅優先探索 (BFS: Breadth First Search)
    - すでに探索した頂点と見探索の頂点の教会を幅いっぱいに捗って拡張しながら探索する。最短経路を求めるアルゴリズムの一つとして応用することができる

## 12.2 グラフの表現
### 隣接行列のよる表現
- 隣接行列表現の長所
    - M[u][v]で辺(u,v)を参照できるので、頂点uとvの関係を定数時間(O(1))で確認できる
    - M[u][v]を辺工数rことで辺の追加や削除を簡単かつ効率的に行うことができる(O(1))
- 隣接行列表現の短所
    - 頂点の2条に比例するメモリを消費する。辺の数が少ない場合はメモリを無駄にしてしまう。
    - 1つの隣接行列では頂点uから頂点vへの関係を1つしか記録できない(基本形の1つの二次元配列ではある頂点のペアに対して2つ以上の辺を引くことができない)

## 12.3 深さ優先探索
深さ優先探索ではスタックを用いて「まだ探索中の頂点」を一時的に保持しておく  
1. 一番最初に訪問する頂点をスタックに入れておく
1. スタックに頂点が積まれている限り、以下の処理を繰り替えす
    - スタックのトップにある頂点uを訪問する
    - 現在訪問中の頂点uから次の頂点vへ移動するときにvをスタックに積む。ただし、現在訪問中の頂点uに未訪問の隣接する頂点がなければuをスタックから削除する

隣接行列を用いた深さ優先探索は書く頂点について全ての頂点に隣接しているかどうかを調べるのでO(|V|^2)のアルゴリズムとなり、大きなグラフに対しては適当ではない  
大きなグラフに対する再帰を用いた深さ優先探索は、言語や環境によってはスタックオーバーフローを起こすので注意が必要  
 
## 12.4 幅優先探索
幅優先探索は地点sからk+1の距離にある頂点を発見する前に、距離kの頂点を全て発見するので、視点から各頂点までの最短距離を順番に求めることができる  
幅優先探索は以下のアルゴリズムに従い、各頂点vについてsからの距離をd[v]に記録する  
1. 始点をキューQに入れる(本門する)
1. Qがからでない限り以下の処理を繰り返す
    - Qから頂点uを取り出し訪問する()
    - uに隣接し、見訪問の頂点vについてd[v]をd[u]+1と更新し、vをQに入れる

隣接行列を用いた幅優先探索は、各頂点に土江すべての頂点に隣接しているかどうかを調べるのでO(|V|^2)のアルゴリズムとなり、大きなグラフに対しては適当ではない

## 12.5 連結成分
隣接リストを用いた深さ優先探索と幅優先探索はある頂点を一度ずつ訪問し、隣接リスト内の頂点(辺)を一度ずつ調べるのでO(|V| + |E|)のアルゴリズムになる  
グラフの隣接リストによる表現には以下の特徴がある  
隣接リストの長所
- 辺の数に比例したメモリしか必要としない

隣接リスト表現の短所
- 頂点uと頂点vの関係を調べるにはuに隣接する頂点の数をnとするとO(n)でリストを探索しなければならない
- 辺の削除を効率的に行えない

# 13章: 重み付きグラフ
## 13.2 最小全域木
グラフG=(V, E)の最小全域木(MST)を求める代表的なアルゴリズムがプリムのアルゴリズム  
#### プリムのアルゴリズム
グラフG=(V, E)の頂点全体の集合をV, MSTに属する頂点の集合をTとする  
1. Gから任意の頂点rを選び、それをMSTのルートとしてTに追加する
1. 次の処理をT=Vとなるまで続ける
    - Tに属する頂点とV-Tに属する頂点を繋ぐ辺の中で、重みが最小のものである辺(pu, u)を選び、それをMSTの辺とし、uをTに追加する

#### 考察
隣接行列を用いたプリムのアルゴリズムは、dが最小である頂点uを探すためにグラフの頂点の数だけ調べる必要があり、この探索を頂点の数だけ行うのでO(|V|^2)のアルゴリズムになる

## 13.2 単一点最短経路
グラフG=(V, E)における単一始点最短経路を求めるためのアルゴリズムの一つがダイクストラのアルゴリズム　　
#### ダイクストラのアルゴリズム
グラフG=(V,E)の頂点全体の集合をV、始点をs、最短経路木に含まれる頂点の集合をSとする  
各計算ステップで最短経路木の辺と頂点を選びSへ追加していく  
  
各頂点iについて、S内の頂点のみを経由したsからiへの最短経路のコストをd[i]、最短経路木におけるiの親をp[i]とする  
1. 初期状態でSを空にする
    - sに対してd[s] = 0
    - s以外のVに属する全ての頂点iに対してd[i] = ∞
1. 以下の処理をS=Vとなるまで繰り返す
    - V - Sの中から、d[u]が最小である頂点uを選択する
    - uをSに追加すると同時に、uに隣接しかつV - Sに属する全ての頂点vに対する値を以下のように更新
        - if d[u] + w(u, v) < d[v]
            d[v] = d[u] + w(u, v)
            p[v] = u

#### 考察
ダイクストラのアルゴリズムのジッッそうはdの値が最小である頂点uをO(|V|)で求める  
これらの処理を|V|回行うので、O(|V|^2)のアルゴリズムとなる  

ダイクストラのアルゴリズムは負の重みの辺を含むグラフには適用できないことに注意  
負の重みの辺を含むグラフに対してはベルマンフォードのアルゴリズムやワーシャルフロイドのアルゴリズムを適用できる  

ダイクストラのアルゴリズムは隣接リストによる表現と、二分ヒープ(優先度付きキュー)を応用することによって、飛躍的に高速化することができる  

#### ダイクストラのアルゴリズム(優先度付きキュー)
グラフG=(V,E)の頂点全体の集合をV,　始点をs, 最短経路木に含まれる頂点の集合をSとする  
各計算ステップで、最短経路木の辺と頂点を選びSへ追加する  

各頂点iについて、S内の頂点のみを経由したsからiへの最短経路のコストをd[i]、最短経路木におけるiの親をp[i]とする

1. 初期状態でSを空とする
    - sに対してd[s]=0
    - s以外のCにぞkぅする全ての頂点iに対してd[i] = ∞
    と初期化する  
    d[i]をキーとして、Vの頂点をmin-ヒープHとして構築する
1. 次の処理をS=Vとなるまで繰り返す
    - Hからd[u]が最小である頂点uを取り出す
    - uをSに追加すると同時にuに隣接しかつV-Sに属する全ての頂点vに対する値を以下のように更新する
        - if d[u] + w(u,v) < d[v]
            d[v] = d[u] + w(u,v)
            p[v] = u
            vを起点にヒープHを更新する

#### 考察
隣接リストと二分ヒープを用いたダイクストラのアルゴリズムの計算量は頂点uを二分ヒープから取り出すためにO(|V|log|V|) の計算が必要になるのでO((|V| + |E|)log|V|)となる  
また隣接リストと優先度付きキューに用いた実装は、|V|の数だけキューから頂点が取り出され、|E|の数だけキューに挿入されるので、同じkぅO((|V|+|E|)log|V|)のアルゴリズムとなる  




































