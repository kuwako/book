# Docker/Kubernetes 実践コンテナ開発入門
# 1章: Dockerの基礎
## Dockerの苦手な部分
- Dockerのコンテナ内部はLinux系OSっぽい構成をしているが、厳密にLinuxとしてふるまうわけではない
- FreeBSDのような非Linux環境を動作させたい場合は実現できない
- あくまでもアプリケーションをデプロイするための箱だと思うべき

## 1.1.2 Dockerの基礎概念
コンテナ型仮想化技術
- 仮想化ソフトウェアなしにOSのリソースを隔離し、仮想OSにする
    - この仮想OSをコンテナと呼ぶ
- OS上にインストールした仮想化ソフトウェアを利用し、ハードウェアを円座員により再現しゲストOSを作り出す仕組みはホストOS型の仮想化と呼ぶ
    - コンテナ型仮想化に比べると、仕組み上のオーバーヘッドが大きい

## 1.1.3 Dockerの考え方に触れる
出来上がったimageはDockerさえ実行されていればホスト環境を問わず実行でき、ホストにNode.jsやnpmをインストールする必要さえない

### LinuxKit
WindosやMacでも使えるLinuxサブシステムの名前
- WindowsやMacではLinuxがサポートされていないため、当初はvirtual boxからDockerを操作していた
- オーバーヘッドがあり使いにくいため、より簡素な環境構築のために作成した

## 1.2.3 本番環境に導入してこそDocker
実際に使用されている例
- AbemaTV
- FRESH LIVE
- アメーバブログ
- Pokemon Go

 クラウドプラットフォーム上での利用例
 - GKE(GCP)
 - ECS(AWS)
 - ACS(AZURE)

 不向きなもの
 - データストア

# 2章: Dockerコンテナのデプロイ
## 2.1 コンテナでアプリケーションを実行する
- Dockerイメージ
    - Dockerコンテナを構成するファイルシステムや、実行するアプリケーションや設定をまとめたもの
    - コンテナを作成するときのテンプレートとなるもの
- Dockerコンテナ
    - Dockerimageをもとに作成され、具現化されたファイルシステムとアプリケーションが実行されている状態

## 2.3.1 Dockerコンテナのライフサイクル
実行中・停止・破棄というライフサイクルになっている

- 実行中
    - Dockerimageをもとにコンテナが作成され、DockerfileのCMDやENTRYPOINTで定義されているアプリケーションの実行を開始する
- 停止
    - ディスクにコンテナ終了時の状態は保持されているので、再実行可能
- 破棄
    - 停止したコンテナは明示的に破棄しない限りディスクに残り続ける
        - 頻繁に実行と停止をするような場合はどんどんディスクを専有していくので不要なコンテナは削除することが望ましい

## 2.5 Docker Composeでマルチコンテナを実行する
- Dockerはアプリケーションのデプロイに特化したコンテナ
    - Dockerコンテナ=単一のアプリケーション
    - 仮想サーバとは対象とする粒度が違う
- docker-composer.ymlにコンテナ同士の依存関係を定義する

## 2.6 Composeによる複数コンテナの実行
- docker_compose.ymlのvolumeというキーでホストや他コンテナとの共有領域を指定できる
- linksキーを使うと他のコンテナとの通信を簡単にできる(IPを調べたりせずに名前解決できる)

# 3 実用的なコンテナの構築とデプロイ
## 3.1.1 1コンテナ = 1プロセス?
### 定期的にジョブを実行するアプリケーション
スケジューラを持たないアプリケーションの場合(cronを使用する場合)、1コンテナ=1プロセスとして行うならば以下の2つの方法が考えられる
- ジョブコンテナ側にジョブの実行トリガーとなるようなAPIを用意し、cronコンテナからコンテナ間通信でこのAPIをコールする
- cronコンテナ上にDockerを構築して、その上でジョブコンテナを実行する

実現不可能ではないが、複雑すぎるため、無理せずに1つのコンテナで複数のプロセスを実行するこの方式のほうがシンプルに完結するユースケースも多い

### 子プロセスまで意識するのは本末転倒
プロセスを過剰に意識するとコンテナをうまく扱えない
- Apacheはクライアントからリクエストを受けるたびにmasterプロセスが子プロセスをforkすることもある
- Nginxの場合はmasterプロセスに加え、workerプロセスやキャッシュマネジメントプロセスも存在している

## 3.1.2 1コンテナに1つの関心事
1プロセス=1コンテナは無理があるが、Docker社はこのことについてどう考えているのか  
Docker公式ドキュメントの'Best practice for writing Dockerfiles'において以下のように述べている
- Each container should have only one concern.

アプリケーションとコンテナの粒度について考える場合、「それぞれのコンテナが担うべき役割を適切に見極め、かつそれがレプリカとして複製された場合でも副作用なくスタックとして正しく動作できる状態になるか」という考えに基づいて設計すると良い

## 3.2 コンテナのポータビリティ
Dockerの大きな利点はポータビリティだが、それは完璧なものではなく、例外が存在する  

### 3.2.1 Kernel・アーキテクチャの違い
- Dockerコンテナが実行できるホストは、ある特定のCPUアーキテクチャやOSの前提に成立している
    - RaspberryPiなど

### 3.2.2 ライブラリ・ダイナミックリンクの課題
- アプリケーションが利用しているライブラリによっても、ポータビリティが損なわれる可能性がある
    - ネイティブライブラリをダイナミックリンクさせるような場合
    - CI側とコンテナ側で採用しているライブラリが違う
        - よくあるケースではCI側がglibcを使い、コンテナ側がmuslを使用しているなど

## 3.3 Dockerフレンドリーなアプリケーション
### 3.3.1 環境変数を活用する
Dockerコンテナとして実行されるアプリケーションを制御する方法は以下4つある
- 実行時引数として値を渡す
    - 実行時引数が増えるとアプrケーション側での引数から任意の変数へのマッピングが増えたりして煩雑になってしまう傾向がある
- 設定ファイルとして渡す
    - 実行するアプリケーションにdevelopmentやproductionといった環境名を与えることで利用する設定ファイルを切り替える方法
    - ポータビリティを下げてしまう
- 環境変数で制御
    - 設定ファイルと比べ、ちょっとした変更で毎回imageをビルドしなくて良い
    - KeyValueの形式でしかデータを保持させられないのがデメリット
- 設定ファイルに環境変数を埋め込む
    - 設定ファイルと環境変数の両方のメリットを活かしているが、環境変数だけでできるのがベスト

Dockerフレンドリに作れるかどうかが、技術選定の軸になりうる

## 3.4 永続化データをどう扱うか
Dockerコンテナ実行中に書き込まれたファイルは、ホスト側にファイル・ディレクトリをマウントしない限りコンテナを破棄したタイミングでディスクから消去される

### 3.4.1 DataVolume 
Dockerコンテナ内のディレクトリをディスク内に永続化する仕組み
- docker container run に -v [マウント先] を指定することで実行可能
- ポータビリティは下がる

### 3.4.2 DataVolumeコンテナ
DataVolumeコンテナを利用する方法ではコンテナ間でディレクトリを共有する
- DataVolumeコンテナではホスト側の/var/lib/docker/volumes/ 以下に配置されるようになっており、コンテナに与える依存性を下げることができる

## 3.5 コンテナ配置戦略


