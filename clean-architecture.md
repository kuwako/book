# Clean Architecture 達人に学ぶソフトウェアの構造と設計
## 1: 設計とアーキテクチャ
ソフトウェアアーキテクチャの目的は求められるシステムを構築・保守するために必要な人材を最小限に抑えること
- 早く進む唯一の方法はうまく進むことである

## 2: 2つの価値のお話
- 振る舞い
- アーキテクチャ

## 3: プログラミングパラダイムの概要
- 構造化プログラミング
  - 直接的な制御の移行に規律を課すもの
    - gotoの廃止forやifのみ
- オブジェクト指向プログラミング
  - オブジェクト指向プログラミングは間接的な制御の移行に規律を課すもの
- 関数型プログラミング
  - 関数型プログラミングは代入に規律を課すもの

## 5: オブジェクト指向プログラミング
- オブジェクト指向とはポリモーフィズムを使ってシステムにある全てのソースコードの依存関係を絶対的に制御する能力

## 6: 関数型プログラミング
- 不変性とアーキテクチャ
  - 不変であれば競合状態やデッドロック状態、並行更新の問題の原因自体がなくなる

# 設計の原則
- 変更に強い
- 理解しやすい
- コンポーネントの基盤として、多くのソフトウェア・システムで利用できる

SOLIDの原則
- 単一責任の原則(Single Responsibility Principle)
  - 個々のモジュールを変更する理由がたったひとつだけになるようにするという原則
- オープン・クローズドの原則(Open-Closed Principle)
  - ソフトウェアを変更しやすくするために、既存のコードの変更よりも新しいコードの追加によってシステムの振る舞いを変更できるように設計すべきという原則
- リスコフの置換原則(Liskov Substitution Principle)
  - 交換可能なパーツを使ってソフトウェア・システムを構築するなら、個々のパーツが交換可能となるような契約に従わなければいけないことという原則
- インターフェイス分離の原則(Interface Segregation Principle)
  - ソフトウェアを設計する際には、使っていないものへの依存を回避すべきという原則
- 依存関係逆転の原則(Dependency Inversion Principle)
  - 上位レベルの方針の実装コードは下位レベルの詳細の実装コードに依存すべきではなく、逆に詳細側が方針に依存すべきであるという原則

## 7: 単一責任の原則
### 想定外の重複  
給与システムにおける Employeeクラス が以下のメソッドを実装しているとする
- 経理部門が使うcalculatePay()
- 人事部門が使うreportHours()
- データベース管理者が使うsave()

これは単一責任の原則に違反している。3つのメソッドがそれぞれ別々のアクターに対する責務を負っている
- アクターの異なるコードは分割すべき

### マージ
- DBAチームと人事チームが同時にEmployeeクラスを編集し、マージした際に何がおきるのか

### 解決策
- 3つの別のクラスを作り、共通のデータの入れ物としてEmployeeDataクラスを使う
  - このクラスはデータ構造を持つだけ
- 3つのクラスはそれぞれ特定の昨日に必要なソースコードだけを保持する
  - 他のコードのことは知らない
- Facadeパターンを利用するとより便利に使える
